// cosmic-connect-applet/src/backend.rs
//! Backend interface using D-Bus client to communicate with kdeconnect-service

use anyhow::Result;
use kdeconnect_dbus_client::{KdeConnectClient, ServiceEvent};
use std::sync::Arc;
use tokio::sync::Mutex;
use std::collections::HashMap;
use futures::StreamExt;

use crate::models::Device;

lazy_static::lazy_static! {
    static ref CLIENT: Arc<Mutex<Option<Arc<KdeConnectClient>>>> = Arc::new(Mutex::new(None));
    static ref DEVICE_CACHE: Arc<Mutex<HashMap<String, Device>>> = Arc::new(Mutex::new(HashMap::new()));
}

/// Initialize the D-Bus client connection
pub async fn initialize() -> Result<()> {
    eprintln!("=== Initializing D-Bus Client ===");
    
    let client = KdeConnectClient::new().await?;
    
    let mut client_guard = CLIENT.lock().await;
    *client_guard = Some(Arc::new(client));
    
    eprintln!("✓ D-Bus client connected to kdeconnect-service");
    Ok(())
}

/// Fetch all devices from the service
pub async fn fetch_devices() -> Vec<Device> {
    let client_guard = CLIENT.lock().await;
    
    let Some(client) = client_guard.as_ref() else {
        eprintln!("⚠️  D-Bus client not initialized");
        return vec![];
    };
    
    match client.list_devices().await {
        Ok(dbus_devices) => {
            let mut cache = DEVICE_CACHE.lock().await;
            let devices: Vec<Device> = dbus_devices.into_iter().map(|d| {
                let device = Device {
                    id: d.id.clone(),
                    name: d.name.clone(),
                    device_type: "phone".to_string(),
                    is_paired: d.is_paired,
                    is_reachable: d.is_reachable,
                    battery_level: None,
                    is_charging: None,
                    network_type: None,
                    signal_strength: None,
                    pairing_requests: 0,
                    has_battery: false,
                    has_ping: true,
                    has_sms: true,
                    has_contacts: false,
                    has_clipboard: true,
                    has_findmyphone: true,
                    has_share: true,
                    has_sftp: false,
                    has_mpris: false,
                    has_remote_keyboard: false,
                    has_presenter: false,
                    has_lockdevice: false,
                    has_virtualmonitor: false,
                };
                cache.insert(d.id.clone(), device.clone());
                device
            }).collect();
            devices
        }
        Err(e) => {
            eprintln!("✗ Failed to fetch devices: {:?}", e);
            vec![]
        }
    }
}

/// Update device in cache
pub async fn update_device(device_id: String, device: Device) {
    let mut cache = DEVICE_CACHE.lock().await;
    cache.insert(device_id, device);
}

/// Remove device from cache
pub async fn remove_device(device_id: &str) {
    let mut cache = DEVICE_CACHE.lock().await;
    cache.remove(device_id);
}

/// Pair with a device
pub async fn pair_device(device_id: String) -> Result<()> {
    let client_guard = CLIENT.lock().await;
    
    let Some(client) = client_guard.as_ref() else {
        return Err(anyhow::anyhow!("D-Bus client not initialized"));
    };
    
    client.pair_device(&device_id).await
}

/// Unpair from a device
pub async fn unpair_device(device_id: String) -> Result<()> {
    let client_guard = CLIENT.lock().await;
    
    let Some(client) = client_guard.as_ref() else {
        return Err(anyhow::anyhow!("D-Bus client not initialized"));
    };
    
    client.unpair_device(&device_id).await
}

/// Send a ping to a device
pub async fn ping_device(device_id: String) -> Result<()> {
    let client_guard = CLIENT.lock().await;
    
    let Some(client) = client_guard.as_ref() else {
        return Err(anyhow::anyhow!("D-Bus client not initialized"));
    };
    
    client.send_ping(&device_id, "Ping from COSMIC!").await
}

/// Send files to a device
pub async fn send_files(device_id: String, files: Vec<String>) -> Result<()> {
    let client_guard = CLIENT.lock().await;
    
    let Some(client) = client_guard.as_ref() else {
        return Err(anyhow::anyhow!("D-Bus client not initialized"));
    };
    
    client.send_files(&device_id, files).await
}

/// Send clipboard content to a device
pub async fn send_clipboard(device_id: String, content: String) -> Result<()> {
    let client_guard = CLIENT.lock().await;
    
    let Some(client) = client_guard.as_ref() else {
        return Err(anyhow::anyhow!("D-Bus client not initialized"));
    };
    
    client.send_clipboard(&device_id, &content).await
}

/// Browse device filesystem (via SFTP)
pub async fn browse_device_filesystem(_device_id: String) -> Result<()> {
    eprintln!("⚠️  Browse filesystem not yet implemented via D-Bus");
    // TODO: Implement SFTP browsing through D-Bus
    Ok(())
}

/// Accept a pairing request
pub async fn accept_pairing(device_id: String) -> Result<()> {
    // Pairing acceptance is handled automatically by the service
    // Just trigger a pair request
    pair_device(device_id).await
}

/// Reject a pairing request
pub async fn reject_pairing(device_id: String) -> Result<()> {
    // Rejecting is essentially unpairing
    unpair_device(device_id).await
}

/// Ring a device (findmyphone)
pub async fn ring_device(device_id: String) -> Result<()> {
    let client_guard = CLIENT.lock().await;
    
    let Some(client) = client_guard.as_ref() else {
        return Err(anyhow::anyhow!("D-Bus client not initialized"));
    };
    
    client.ring_device(&device_id).await
}

/// Request SMS conversations from a device
pub async fn request_conversations(device_id: String) -> Result<()> {
    let client_guard = CLIENT.lock().await;
    
    let Some(client) = client_guard.as_ref() else {
        return Err(anyhow::anyhow!("D-Bus client not initialized"));
    };
    
    client.request_conversations(&device_id).await
}

/// Request a specific SMS conversation thread
pub async fn request_conversation(device_id: String, thread_id: i64) -> Result<()> {
    let client_guard = CLIENT.lock().await;
    
    let Some(client) = client_guard.as_ref() else {
        return Err(anyhow::anyhow!("D-Bus client not initialized"));
    };
    
    client.request_conversation(&device_id, thread_id).await
}

/// Send an SMS message
pub async fn send_sms(device_id: String, phone_number: String, message: String) -> Result<()> {
    let client_guard = CLIENT.lock().await;
    
    let Some(client) = client_guard.as_ref() else {
        return Err(anyhow::anyhow!("D-Bus client not initialized"));
    };
    
    client.send_sms(&device_id, &phone_number, &message).await
}

/// Create a stream of service events
pub async fn event_stream() -> futures::stream::BoxStream<'static, ServiceEvent> {
    use tokio::sync::mpsc;
    use tokio::time::{sleep, Duration};
    
    let (tx, rx) = mpsc::channel::<ServiceEvent>(100);
    
    // Spawn background task to listen for events
    tokio::spawn(async move {
        // Wait for client to be initialized (with timeout)
        let mut attempts = 0;
        let client = loop {
            let client_guard = CLIENT.lock().await;
            if let Some(client) = client_guard.clone() {
                drop(client_guard);
                break client;
            }
            drop(client_guard);
            
            attempts += 1;
            if attempts > 20 {
                eprintln!("⚠️  Timeout waiting for D-Bus client initialization");
                return;
            }
            
            eprintln!("⏳ Waiting for D-Bus client initialization... (attempt {})", attempts);
            sleep(Duration::from_millis(100)).await;
        };
        
        eprintln!("✓ Event stream: D-Bus client ready");
        
        let mut stream = client.listen_for_events().await;
        
        while let Some(event) = stream.next().await {
            if tx.send(event).await.is_err() {
                eprintln!("Event receiver dropped, stopping event listener");
                break;
            }
        }
        
        eprintln!("Event stream ended");
    });
    
    // Return stream from channel that never ends
    futures::stream::unfold(rx, |mut rx| async move {
        match rx.recv().await {
            Some(event) => Some((event, rx)),
            None => {
                // Channel closed, sleep forever instead of ending
                // This prevents the unfold panic
                loop {
                    sleep(Duration::from_secs(3600)).await;
                }
            }
        }
    }).boxed()
}
